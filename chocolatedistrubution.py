# -*- coding: utf-8 -*-
"""chocolatedistrubution

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vjo0BfaPuhAjnXaBoK30kbZx9ST8hsEB
"""

class Chocolate: # This line defines a new class named Chocolate
    def __init__(self, weight, price, type, brand):#This line defines a special method called __init__, which is a constructor method used to initialize objects of the class. It takes four parameters: weight, price, type, and brand.
        self.weight = weight # This line sets the weight attribute of the chocolate object to the value passed as the weight parameter
        self.price = price # This line sets the price attribute of the chocolate object to the value passed as the price parameter.
        self.type = type  # This line sets the type attribute of the chocolate object to the value passed as the type parameter
        self.brand = brand # This line sets the brand attribute of the chocolate object to the value passed as the brand parameter.

def distribute_chocolates_iter(chocolates, students):#This line defines a function for the iterative method
    if len(chocolates) < len(students):# This line presents an if statement that checks if the number of chocolates is less than the number of students.
        return "Not enough chocolates for each student" #If the condition is met the code would return 'Not enough chocolates for each student'

    chocolates.sort(key=lambda x: (x.price, x.weight), reverse=True) # This line sorts chocolates by price and weight in descending order

    result = {} #This is an empty dictionary that will store the results
    for i, student in enumerate(students): #Loop over each student with their index
        result[student] = chocolates[i] #This line assigns each student a chocolate based on the sorted list
    return result #This line returns a dictionary of the results

def distribute_chocolates_rec(chocolates, students, result=None):#This line defines a function for the recursive method
    if len(chocolates) < len(students): #This line presents an if statement that checks if the number of chocolates is less than the number of students.
        return "Not enough chocolates for each student" #If the condition is met the code would return 'Not enough chocolates for each student'

    if result is None:#This line checks if the result dictionary is not provided
        result = {} #This line intilaizes the result dictionary if it's not provided

    if not students: #This line checks if there are no more students left
        return result #This line returns the result dictionary when all students have been assigned chocolates

    result[students[0]] = chocolates.pop(0) #This line assigns chocolate to the first student and remove it from the list
    return distribute_chocolates_rec(chocolates, students[1:], result) #This line is a recursive call to assign chocolates to remaining students

# The Test Cases
chocolates = [
    Chocolate(20, 25.99, "dark", "Cadbury"),
    Chocolate(15, 15.50, "milk", "Hershey's"),
    Chocolate(10, 10.75, "white", "Nestle"),
    Chocolate(25, 30.25, "dark", "Godiva"),
    Chocolate(30, 13.49, "milk", "Lindt"),
] #This line defines a list of Chocolate objects with various attributes

students = ["Hind", "Abdulla", "Rashid", "Noora", "Hissa"] #This line defines a list of students

# Testing the iterative function
print("Iterative Result:") #This line prints a message indicating the start of iterative result printing
iterative_result = distribute_chocolates_iter(chocolates, students) #This line calls the iterative function to distribute chocolates
for student, chocolate in iterative_result.items(): #This line iterates over the result dictionary
    print(f'{student} : The chocolate type is: {chocolate.type} , the brand is: {chocolate.brand}, the weight is:{chocolate.weight}, the price is:{chocolate.price}') #This line will print each students name with the assigned chocolate type, weight , price and brand.

# Testing the recursive function
print("\nRecursive Result:") #This line prints a message indicating the start of recursive result printing
recursive_result = distribute_chocolates_rec(chocolates, students) #This line calls the recusrive function to distribute chocolates
for student, chocolate in recursive_result.items():  #This line iterates over the result dictionary
    print(f'{student} : The chocolate type is: {chocolate.type} , the brand is: {chocolate.brand}, the weight is:{chocolate.weight}, the price is:{chocolate.price}') #This line will print each students name with the assigned chocolate type, weight , price and brand.

class Chocolate:#This line defines a class to represent the chocolate objects
    def __init__(self, weight, price, type, brand): # This line uses the constructor to initialize Chocolate object attributes
        self.weight = weight  # Assign weight attribute
        self.price = price  # Assign price attribute
        self.type = type  # Assign type attribute
        self.brand = brand  # Assign brand attribute

def quick_sort(chocolates, key): #Define a function to represent the quick sort method to sort the chocolates
    if len(chocolates) <= 1: #If statement to checl if the number of chocolates is less than or equal to 1
        return chocolates #If the condition it met then it would return the list of chocolates
    pivot = chocolates[len(chocolates) // 2] #This line chooses a pivot element from the middle of the list
    left = [chocolate for chocolate in chocolates if key(chocolate) < key(pivot)] #This line creates a list of elements smaller than the pivot
    middle = [chocolate for chocolate in chocolates if key(chocolate) == key(pivot)]#This line creates a list of elements equal to the pivot
    right = [chocolate for chocolate in chocolates if key(chocolate) > key(pivot)] # This line creates a list of elements greater than the pivot
    return quick_sort(left, key) + middle + quick_sort(right, key) #This line recursively sort and merge the left middle and right lists


def sort_chocolates_by_weight(chocolates): #Define a function to sort the chocolates by weight
    return quick_sort(chocolates, key=lambda x: x.weight) # This line calls the quick_sort function with a key function to sort by weight

def sort_chocolates_by_price(chocolates):##Define a function to sort the chocolates by price
    return quick_sort(chocolates, key=lambda x: x.price) #This line calls the quick_sort function with a key function to sort by price

# The Test case
chocolates =[
    Chocolate(20, 25.99, "dark", "Cadbury"),
    Chocolate(15, 15.50, "milk", "Hershey's"),
    Chocolate(10, 10.75, "white", "Nestle"),
    Chocolate(25, 30.25, "dark", "Godiva"),
    Chocolate(30, 13.49, "milk", "Lindt"),
] #This line defines a list of Chocolate objects with various attributes

# Sorting chocolates by weight and price
sorted_by_weight = sort_chocolates_by_weight(chocolates) #This line calls the function to sort chocolates by weight
sorted_by_price = sort_chocolates_by_price(chocolates) #This line calls the function to sort chocolates by price

# Output sorted by weight
print("Sorted by weight:") #This line prints a message indicating the start of output sorted by weight
for chocolate in sorted_by_weight: #This line iterates over the list of chocolates sorted by weight
    print(chocolate.brand, ',' ,chocolate.type,':', chocolate.weight) #This line prints the chocolate brand , type and weight based on sorting by the weight

# Output sorted by price
print("\nSorted by price:") #This line prints a message indicating the start of output sorted by price
for chocolate in sorted_by_price: #This line iterates over the list of chocolates sorted by price
    print(chocolate.brand, ',' ,chocolate.type, ':', chocolate.price) #This line prints the chocolate brand , type and weight based on sorting by the price

def binary_search(array, target, key=lambda x: x):
    left, right = 0, len(array) - 1

    while left <= right:
        mid = (left + right) // 2
        mid_value = key(array[mid])
        if mid_value == target:
            return mid
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

def find_chocolate_by_price(chocolates, price): #This line defines a function to find the chocolate by price
    index = binary_search(chocolates, price, key=lambda x: x.price) #This line calls the binary_search function with a key function to search by price
    return chocolates[index] if index != -1 else None #This line returns the chocolate found by price if it exists, otherwise return None

def find_chocolate_by_weight(chocolates, weight): #This line defines a function to find the chocolate by weight
    index = binary_search(chocolates, weight, key=lambda x: x.weight) #This line calls the binary_search function with a key function to search by weight
    return chocolates[index] if index != -1 else None #This line returns the chocolate found by weight if it exists, otherwise return None

# The Test cases for searching by price
chocolate_by_price = find_chocolate_by_price(sorted_by_price, 30.25) #This line calls the function to find chocolate by price
if chocolate_by_price: #This line checks if chocolate by price is found
    print("Chocolate found by price :", chocolate_by_price.brand,',' ,chocolate_by_price.type, '(price:', chocolate.price, ')') #This line prints the chocolate brand and type according to the chosen price
else: #If chocolate by price is not found
    print("Chocolate not found by price ") #This line prints a message indicating chocolate not found by price

chocolate_by_price_not_found = find_chocolate_by_price(sorted_by_price, 20) #This line calls the function to find chocolate by price (not found case)
if chocolate_by_price_not_found: #This line checks if chocolate by price is found (not found case)
    print("Chocolate found by price:", chocolate_by_price_not_found.weight, chocolate_by_price_not_found.price, chocolate_by_price_not_found.type, chocolate_by_price_not_found.brand) #This line prints the chocolate brand and type according to the chosen price (not found case)
else: #If chocolate by price is not found (not found case)
    print("Chocolate not found by price") #This line prints a message indicating chocolate not found by price

# The Test cases for searching by weight
chocolate_by_weight = find_chocolate_by_weight(sorted_by_weight, 10) #This line calls the function to find chocolate by weight
if chocolate_by_weight: #This line checks if chocolate by weight is found
    print("Chocolate found by weight:", chocolate_by_price.brand,',' ,chocolate_by_price.type, '(weight:', chocolate.weight, ')') #This line prints the chocolate brand and type according to the chosen weight
else: #If chocolate by price is not found
    print("Chocolate not found by weight") #This line prints a message indicating chocolate not found by price

chocolate_by_weight_not_found = find_chocolate_by_weight(sorted_by_weight, 12) #This line calls the function to find chocolate by weight (not found case)
if chocolate_by_weight_not_found: #This line checks if chocolate by price is found (not found case)
    print("Chocolate found by weight:", chocolate_by_weight_not_found.weight, chocolate_by_weight_not_found.price, chocolate_by_weight_not_found.type, chocolate_by_weight_not_found.brand)#This line prints the chocolate brand and type according to the chosen weight (not found case)
else: #If chocolate by price is not found (not found case)
    print("Chocolate not found by weight ")#This line prints a message indicating chocolate not found by price
